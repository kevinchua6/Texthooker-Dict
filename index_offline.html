<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

<title>Texthooker</title>
<style type="text/css">

html {
scroll-behavior: smooth;
}

body {
	background-color: #bababa;
	color: #000000;
	height: 50000px;
}

/* For loading screen */
#dimScreen
{
    position:fixed;
    padding:0;
    margin:0;

    top:0;
    left:0;

    width: 100%;
    height: 100%;
    background:rgba(255,255,255,0.5);
}

#loader {
	position: absolute;
	left: 50%;
	top: 50%;
	z-index: 1;
	width: 150px;
	height: 150px;
	margin: -75px 0 0 -75px;
	border: 16px solid #f3f3f3;
	border-radius: 50%;
	border-top: 16px solid #3498db;
	width: 120px;
	height: 120px;
	animation: spin 2s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
/* For loading screen */

.container {
	position:fixed;
	top:3px;
	right:5px;
	display:inline-block;
}

#counter {
	background-color:rgba(25,25,25,0.8);
	color:#9d9d9d;
	font-size:.4em;
	line-height:100%;
	float:left;
	padding-left:8px;
	padding-right:8px;
	padding-top:5px;
	padding-bottom:5px;
}



#remove_button {
	background-color:rgba(25,25,25,0.8);
	color:#9d9d9d;
	font-size:.4em;
	line-height:100%;
	float:right;
	margin-right:10px;
	padding-left:8px;
	padding-right:8px;
	padding-top:5px;
	padding-bottom:5px;
	cursor:pointer;
	cursor:hand;
}

#selection_popup {
	color: black;
	border: solid darkblue 1px;
	background-color: lightgoldenrodyellow;
	position: absolute;
	display: none;
	white-space: pre-line;
}

.toggle_scrolling_button {
	background-color:rgba(25,25,25,0.8);
	color:#9d9d9d;
	font-size:1em;
	line-height:100%;
	margin-right:4px;
	padding-top:5px;
	padding-bottom:5px;
	padding-left:8px;
	padding-right:8px;
	float:right;
	cursor:pointer;
	cursor:hand;
}

.btn {
	display: inline-block;
	font-weight: 400;
	color: #212529;
	text-align: center;
	vertical-align: middle;
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
	background-color: transparent;
	border: 1px solid transparent;
	padding: .375rem .75rem;
	font-size: 1rem;
	line-height: 1.5;
	border-radius: .25rem;
	transition: color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;
}

#alert-success {
	padding: 0.75rem 1.25rem;
	margin-bottom: 1rem;
	border: 1px solid transparent;
	border-radius: 0.25rem;
	position: fixed;
	color: #155724;
	background-color: #d4edda;
	border-color: #c3e6cb;
	bottom: 10%;
	left: 50%;
	transform: translate(-50%, -50%);
	opacity: 0.7;
	display: none;
}




</style>
<!------------------------

To change background color or text color, just replace the style values above with the hex values for the colors you want.
If you want the background of the counter to remain semi-transparent, you must use rgb values like above. The last number (where I've put 0.8) is the opacity level (1.0 = completely opaque).
To change font size, just change the em value to what works for you (the standard size is 1, I like it at 1.5).
To change font weight (boldness), just edit the value above.  100 is quite thin, 400 is default, 900 is quite thick.  You may want it higher than default for Mincho fonts.
The line-height value changes the spacing between lines.

To use the font of your choice, remove the list of fonts above and put the ENGLISH name of your font in quotation marks (some JP font names are in Japanese, such as "ä¸‰æ¬¡å…ƒåˆ‡çµµå­—").
Be sure to leave a semi-colon at the end of the line.
To find the English name of a given font, first install it, then open Firefox.
Go to about:preferences#content in the address bar, then click on the 'Default font' drop-down menu.
The "correct" name of your font will be listed here - just copy that down and paste it up above.

Note that if you would like to use your browser default font, replace the font-family line with font-family:""; or delete it altogether.
Your default is probably Gothic - if you want to try out a good Mincho font, try Aozora Mincho at http://www.freejapanesefont.com/aozora-mincho-download/
For various other free Japanese fonts, visit http://www.freejapanesefont.com/
For more font attribute information visit http://www.w3schools.com/css/css_font.asp

------------------------>
<div id="selection_popup">&lt;- selection</div>
<link rel="stylesheet" type="text/css" href="Texthookertest_files/popup.css" id="rikaichamp-css"></head>
<body style="background-color: rgb(32, 32, 32); color: rgb(188, 188, 188);">
<div>何気無く死んでいた。俺はそういう人間なんだぜ。</div>
<div class="container">
	<button id="toggle-light" class="toggle_scrolling_button" title="Toggle dark/light mode">L</button>
	<button id="toggle-scrolling" class="toggle_scrolling_button" title="Toggle scrolling">O</button>
<!-- This is the div used for the "remove last line" button. -->
	<button id="remove_button" title="Remove last line" >x</button>
<!-- End button div. -->

<!-- This is the div used for the counter. -->
	<div id="counter" title="No. of characters / No. of lines">No. of characters / No. of lines</div>
<!-- End counter div. -->
</div>
<div id="dimScreen"></div>
<div id="loader"></div>
<!-- jQuery is needed for the page to run. You can change this to an offline version if you prefer. -->
		<meta charset="utf-8">
		<title>Texthooker</title>
		<script type="text/javascript" src="resources/jquery.js"></script>
		<script type="text/javascript" src="resources/automatic_scrolling.js"></script>
		<script type="text/javascript" src="resources/main.js"></script>
		
<div id= "alert-success">Dictionary loaded!</div>

<script>

$(document).ready(function(){
	//Change the color of the text of the definition when it becomes light/dark mode
	//when click/ touchscreen/highlights other stuff it removes the definition

	//Loads the old saved text
	loadSavedText()

	//window.setTimeout($("#alert-success").fadeOut(), 5000);

	
function saveTextIntoString(){
	//Saves the text
	var entire_text = document.getElementsByTagName("p");
	var entire_text_string = ''
	for (line of entire_text) {
		entire_text_string += "<p>"+line.innerHTML+"</p>"
	}
	localStorage.setItem('saved_text', entire_text_string);
	//alert('Text saved!');
}

function loadSavedText(){
	var entire_text_string = localStorage.getItem('saved_text');
	if (entire_text_string){
		document.body.innerHTML += entire_text_string
	}
}


//loads dictionary
function loadDictionary(){
	var req = new XMLHttpRequest();
	req.open("GET", "dict.dat", false);
	//req.open("GET", "data/dict.dat", false); //add this when everything is done
	// Delete loading screen
	document.getElementById("loader").style.display = "none";
	document.getElementById("dimScreen").style.display = "none";
	req.send();
	console.log("dictionary: "+ req.responseText);
	return req.responseText;
}

document.getElementById("loader").style.display = "none"; //remove
document.getElementById("dimScreen").style.display = "none"; //remove
//loads the dictionary as one continuous string to reduce memory use
const wordDict = `何気無く [なにげなく] /(adv) unintentionally/calmly/inadvertently/innocently/(P)/
何点 [なんてん] /(exp) what score or grade?/
何物 [なにもの] /(n) something/nothing (with neg. verb)/
何用で [なにようで] /(exp) on what business/
何番 [なんばん] /(n) what number/
何番目 [なんばんめ] /(n) what number/rank?/
Ω [オメガ] /(n) omega/(P)/
α [アルファ] /(n) alpha/(P)/
α崩壊 [アルファほうかい] /(n) alpha decay/
α粒子 [アルファりゅうし] /(n) alpha particle/
β [ベータ] /(n) beta/(P)/
βカロチン [ベタカロチン] /(n,ik) beta-carotene/
βカロチン [ベタカロテン] /(n,ik) beta-carotene/
βカロチン [ベータカロチン] /(n) beta-carotene/
βカロチン [ベータカロテン] /(n) beta-carotene/
βカロテン [ベタカロチン] /(n,ik) beta-carotene/
βカロテン [ベタカロテン] /(n,ik) beta-carotene/
βカロテン [ベータカロチン] /(n) beta-carotene/
βカロテン [ベータカロテン] /(n) beta-carotene/
β崩壊 [ベータほうかい] /(n) beta decay/
β版 [ベータばん] /(n) beta version/
γ崩壊 [ガンマほうかい] /(n) gamma decay/
γ線 [ガンマせん] /(n,adj-no) gamma rays/
ε [イプシロン] /(n) epsilon/`
console.log("dictionary: "+ wordDict);

//alert(wordDict);


// Code that adds a delay to the selection detection to prevent multiple detections
function debounce(fn, delay) {
  let timer = null;
  return function () {
    var context = this, args = arguments;
    clearTimeout(timer);
    timer = setTimeout(function () {
      fn.apply(context, args);
    }, delay);
  };
};

function getDefinition(){
	var selection = (document.getSelection ? document.getSelection().toString() :  document.selection.createRange().toString()).trim();
	//if selection is not blank
	if (selection !== ''){
		console.log("What I selected: "+ selection);
        //If word is in dict
		if (wordDict.includes(selection)){
			//console.log('wordDict: ' +wordDict)
			//console.log('selection: '+selection)
			//alert('woo hoo!')

            //Find the word in its proper definition (ie not inside other words like "in" in "inside")
			//https://regex101.com/ good website for regex
			var re = new RegExp ("^"+selection+"[^\n]+", 'mg');
			var def_word_re = wordDict.matchAll(re);
			var all_def = '';
			for (var def of def_word_re){
				all_def += def + "\n ";
			};

            //Makes sure that the definition is not blank
            if (all_def != ""){
				console.log("I am the definition: " + all_def.slice(0,-3))
				return (all_def);
			}
        }
	}
}



function displayDefinition(def){
	//Unicode stuff
	var markerTextChar = "\ufeff";
    var markerTextCharEntity = "&#xfeff;";

	//Assign markerId to the thing on the right and declare markerEl
	//Make markerId unique, combining time and a random string 
    var markerEl, markerId = "sel_" + new Date().getTime() + "_" + Math.random().toString().substr(2);

    return function(win) {
		//Asign win to window if win is falsy
        win = win || window;
		//Document of window
        var doc = win.document;
        var sel, range;

		var selectionEl = doc.getElementById('selection_popup');

        // Branch for IE <= 8 
        if (doc.selection && doc.selection.createRange) {
            // Clone the TextRange and collapse
            range = doc.selection.createRange().duplicate();
            range.collapse(false);

            // Create the marker element containing a single invisible character by creating literal HTML and insert it
            range.pasteHTML('<span id="' + markerId + '" style="position: relative;">' + markerTextCharEntity + '</span>');
            markerEl = doc.getElementById(markerId);
        } else if (win.getSelection) {
			//For IE >= 9
            sel = win.getSelection();
            range = sel.getRangeAt(0).cloneRange();
			//Collapse range to the end (shorten it)
            range.collapse(false);

            // Create the marker element containing a single invisible character using DOM methods and insert it
            markerEl = doc.createElement("span");
            markerEl.id = markerId;
			//?
            markerEl.appendChild( doc.createTextNode(markerTextChar) );
			//Inserts a node at the start of the range
            range.insertNode(markerEl);
        }

        if (markerEl) {
            // Lazily create element to be placed next to the selection

			// // If selectionEl is not defined yet
			// //NOTE: just create selectionEl beforehand/in the html so that it would not get scrolled down all the time
            // if (!selectionEl) {
            //     selectionEl = doc.createElement("div");
            //     selectionEl.style.border = "solid darkblue 1px";
            //     selectionEl.style.backgroundColor = "lightgoldenrodyellow";
            //     selectionEl.innerHTML = "&lt;- selection";
            //     selectionEl.style.position = "absolute";

            //     doc.body.appendChild(selectionEl);
            // }

     	 	// Find markerEl position http://www.quirksmode.org/js/findpos.html

			// assign obj to marker element
			var obj = markerEl;

			var left = 0, top = 0;
			do {
				left += obj.offsetLeft;
				top += obj.offsetTop;
			} while (obj = obj.offsetParent);

			//minor adjustments to the placement of the text
			left += 15;
			top += 35;

			// Move the button into place.
			// Substitute your jQuery stuff in here
			selectionEl.style.display = 'block';
			selectionEl.style.left = left + "px";
			selectionEl.style.top = top + "px";

			//Change the text to the definition
			selectionEl.innerHTML = def;

			markerEl.parentNode.removeChild(markerEl);
			}
    };
}





// Listens for selections 
document.addEventListener("selectionchange", debounce(function (event) {
	//Remove old definition
	document.getElementById('selection_popup').style.display = 'none';

	wordDefinition = getDefinition();
	if (wordDefinition){
		window.setTimeout(displayDefinition(wordDefinition), 1000)
	}

}, 250));


function scrollToNewestLine(){
        // Find position of last element
        var all_p = document.querySelectorAll("p");
		var p = all_p[all_p.length -1];
		//Find current scroll position
        var scroll_position = p.offsetTop - $(window).height() * 2 / 3;

		// If we are at the bottom, go to the bottom again.
        window.scrollTo(0, scroll_position);
        return scroll_position;
};

	
	
//The text inserter/scroller and the counter begin here.

//These are needed later.
oldlines = 0;
chars = 0;

//Replacement for the event listener for DOM nodes
// Options for the observer (which mutations to observe)
const config = { attributes: true, childList: true, subtree: true };
// Callback function to execute when mutations are observed
var timeBeforeSave;
const callback_DOM = function(mutationsList, observer) {
	// Saves everytime a new node is inserted.
	//saveTextIntoString();
	//Cancel previous time if exists
	
	clearTimeout(timeBeforeSave)
	
	
	//Wait 20s before it saves
	timeBeforeSave = setTimeout(saveTextIntoString, 20000)

	//Counter begins here. Get the current number of lines first.
	var lines = document.getElementsByTagName('p').length;
  
  //Second, confirm whether the node insertion was a new line.
  //(Rikai also inserts and removes a node (a div).)
  var isnew = lines - oldlines;
  if ( isnew > 0 ){
  	  //If it is a new line, do a character count of the line and add it to the running tally.
	  var i=lines-1
  	  var newline = document.getElementsByTagName('p')[i].innerHTML;
  	  var linechars = newline.length;
  	  newchars = chars + linechars;
  	  
	  //Make the numbers look nice.
	  var charsdisp = newchars.toLocaleString();
	  var linesdisp = lines.toLocaleString();
	  
	  //Print the new counts into the counter.
	  jQuery('#counter').text("Chars: "+charsdisp+' / Lines: '+linesdisp);
	  
	  //Get ready for the next line.
	  oldlines = lines;
	  chars = newchars;
	  
      //The counter ends here and the text-scroller is below.
      //I've included it in the "if new line" statement.
      //(That is, it won't run unless a new line was added.)
	  //Like this it won't autoscroll down every time Rikai is used.
	  
      var latest_scroll_position = scrollToNewestLine();
       
  }; //This is the end of the "if new line" statement.

};
// Create an observer instance linked to the callback function
const observer = new MutationObserver(callback_DOM);
const targetNode = document.body;
observer.observe(targetNode, config);





//End of scroller and counter script.


//Beginning of "remove last line" script.

//Listen for click.
//var to determine if remove_button will be red
var remove_button_red = 0;

//When right click it turns remove_button red and changes a var
$("#remove_button")[0].addEventListener('contextmenu', function(ev) {
    ev.preventDefault();
	
	remove_button_red = !remove_button_red;
	if (remove_button_red){
		//console.log('remove_button_red true');
		//on
		$("#remove_button").css({"background-color": "red"});
	}
	else {
		//console.log('remove_button_red false');
		//off
		$("#remove_button").css({"background-color": "black"});
	}
    return false;
}, false);

$("#remove_button").click(function(){
	//Check whether there are any lines.
	var remove_lines = document.getElementsByTagName('p').length;
	if ( remove_lines > 0 ){
		//If there are, find the last line and do a character count.
		var q = remove_lines - 1;
		var last = document.getElementsByTagName('p')[q].innerHTML;
		var lastlen = last.length;
		  
		//Check what kind of button it is
		if (remove_button_red){ //note also can use the color of the remove button?
			//alert('Are you sure you want to delete?');
			var lines_to_remove = Math.ceil(q/2);
			for (var i=0; i < lines_to_remove; i++){
                $('body').children('p:first').remove();
                
            }
            window.scrollTo(0, latest_scroll_position);
            alert('Cleared half of the lines');
		} 
		else {
  		   	//Remove the last line.
			$('body').children('p:last').remove();
		}
		  	    
  	    //Update the counter.
		var newch = chars - lastlen;
   	    var newchdisp = newch.toLocaleString();
 		var newl = oldlines - 1;
 		var newldisp = newl.toLocaleString();
		jQuery('#counter').text(newchdisp+' / '+newldisp);
		
		//Prepare for next line.
		chars = newch;
		oldlines = newl;
	};
});

//End of "remove last line" script.

let toggle_lights = false; //true is white, false is black.

$("#toggle-light").click(function(){
	toggle_lights = !toggle_lights;
	if (toggle_lights==true){
		//console.log('toggle lights true');
		//on
		$("body").css({"background-color": "#bababa", "color": "#000000"});
	}
	
	if (toggle_lights==false){
		//off
		$("body").css({"background-color": "#202020", "color": "#BCBCBC"});
	}
});



});
</script>


</html>